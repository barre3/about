## Test Driven Development

At barre3, we write tests before code (at least on our rails site). This serves failsafe against future regression to some degree, but we also believe it improves the quality of our code by more clearly defining the requirements. We unit test our models using Rspec and integration test our views and controllers using Cucumber and Capybara. If your new to TDD or need to brush up on TDD best practices, check out the ebook [Rails 4 Test Prescriptions](https://www.dropbox.com/s/v6w96thzvs7z4a2/rails-4-test-prescriptions_p1_0.epub?dl=0). 

There are a few exeptions where we don't worry about test coverage: 

1. Administrative section - Given that it's not customer facing and is generated by active admin, this doesn't seem worth the trouble. 
2. Legacy classes

### Outside in testing 

We begin feature development with a high-level cucumber-based end to end (integration) test that frames the problem in a customer-centric story. We run the test. If there's a trivial failure, we update code (usually in the controller or view). If there's a significant failure like business logic not working, we take a step back and write a unit test. This is visualized in the following chart: 

### Continuous Integration

When changes are pushed to origin, a service called Circle CI runs all Rspec and Cucumber tests. If the change was on the "master" or "Develop" branch and the tests succeed, the code is deployed to production or staging, respectively. If the tests fail, the author of the failed commit is notified (as well as the team via Slack). If you want to avoid the embarassment of breaking the build, run the tests locally before pushing! 

### Coverage Metrics

When test are run on the build server, coverage metrics via SimpleCov are reported to [Coveralls](https://coveralls.io). Coveralls has a nice web interface to view SimpleCov results for each build and view average trends over time. It's also the enforcer of TDD. If the percentage of code covered is less than a given threshold (currently 80%, but will increase), the build fails and changes are not deployed to staging/production. All classes that do not need to be tested can be excluded from SimpleCov (and not count against coverage) by being filtered out like this:

    SimpleCov.formatter = Coveralls::SimpleCov::Formatter
    SimpleCov.start do
      add_filter 'app/models/legacy'
      add_filter 'app/admin'
    end

## Version Control

### Github Centralized

While our production environments have their own repositories, all commits are centralized through github, which you should set up as your "origin" repository. Push all commits to origin and not directly to the production environments. 

### Gitflow Workflow

We practice [Gitflow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow) at barre3 to organize our work into branches that correspond to a work item in Sprint.ly. When you commit code, never commit it to the master branch. Always commit code to a feature branch. You should name your feature branch "feature/" then the number of the work item in Sprint.ly, then an optional dash-separated description of the work item. For example, I was working on a fix for Sprint.ly defect #33 titled "Fix broken thing", I would create the following branch

    git branch feature/33-fix-broken-thing

Or if I'm in a rush or the description is too complicated this is fine too:

    git branch feature/33
    
Feel free to push your branch to origin even if the work is not done. When you do so, the CI server will execute the test suite for your branch but not deploy it to staging. Once your work is done, don't update the status in Sprint.ly to "Complete" just yet. Create a pull request to merge your feature branch into the "Develop" branch and tag the work item with "pre-complete". 

### Code Review via Pull Requests

Code review via pull requests helps detect issues in code as early as possible by getting a second set of eyes on the work. It also helps distribute the understanding of systems throughout the team. Whomever is closing the pull request (probably Peter), will review the code and either a) comment and reject if any issues are present or b) merge if there are no issues. Once merged into master, the CI server will evaluate execute the test suite on the merge and deploy to staging. Once that happens the person closing the pull request will update the status of the Sprint.ly work item to "Completed", notifying QA that it is time to verify the work on staging. 

## Code Formatting

Try to adhere to this [Ruby Style Guide](https://github.com/bbatsov/ruby-style-guide) and [Rails Style Guide](https://github.com/bbatsov/rails-style-guide). Someday, we may adopt [Rubocop](https://github.com/bbatsov/rubocop), but not now. 
